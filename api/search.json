[{"id":"9c99dc11ee58b9118dc125cce366c4cd","title":"非常好矩阵封装","content":"Tips\n支持直接 cin, cout\n\nCodecppnamespace Badnuker &#123;\n    const int mod = 1e9 + 7;\n\n    class Matrix &#123;\n        public:\n            int row, col;\n            int a[105][105];\n\n            Matrix() &#123;\n                memset(a, 0, sizeof(a));\n            &#125;\n\n            Matrix(int x, int y) &#123;\n                row = x;\n                col = y;\n                memset(a, 0, sizeof(a));\n            &#125;\n\n            friend istream &amp; operator&gt;&gt;(istream &amp;is, Matrix &amp;x) &#123;\n                for (int i = 1; i &lt;= x.row; i++) &#123;\n                    for (int j = 1; j &lt;= x.col; j++) &#123;\n                        is &gt;&gt; x.a[i][j];\n                    &#125;\n                &#125;\n                return is;\n            &#125;\n\n            friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Matrix &amp;x) &#123;\n                for (int i = 1; i &lt;= x.row; i++) &#123;\n                    for (int j = 1; j &lt;= x.col; j++) &#123;\n                        os &lt;&lt; x.a[i][j] &lt;&lt; &#39; &#39;;\n                    &#125;\n                    if (i != x.row) &#123;\n                        os &lt;&lt; &#39;\\n&#39;;\n                    &#125;\n                &#125;\n                return os;\n            &#125;\n\n            Matrix operator*(const Matrix &amp; x) &#123;\n                Matrix res(row, x.col);\n                for (int i = 1; i &lt;= row; i++) &#123;\n                    for (int k = 1; k &lt;= col; k++) &#123;\n                        int tmp = a[i][k];\n                        for (int j = 1; j &lt;= x.col; j++) &#123;\n                            (res.a[i][j] += tmp * x.a[k][j]) %= mod;\n                        &#125;\n                    &#125;\n                &#125;\n                return res;\n            &#125;\n\n            void operator*=(const Matrix &amp; x) &#123;\n                (*this) = (*this) * x;\n            &#125;\n\n            void operator%=(const int &amp;x __attribute__((unused))) &#123;&#125;\n    &#125;;\n\n    template&lt;typename T&gt;\n    T ksm(T x, int y) &#123;\n        T res = x;\n        y--;\n        while (y) &#123;\n            if (y &amp; 1) &#123;\n                res *= x;\n            &#125;\n            x *= x;\n            y &gt;&gt;= 1;\n        &#125;\n        return res;\n    &#125;\n&#125;","slug":"非常好矩阵封装","date":"2023-09-29T20:13:34.000Z","categories_index":"","tags_index":"模板","author_index":"Badnuker"},{"id":"388a2cc7ccd390e63439623ba88b8119","title":"实用网站索引","content":"（实时更新中）\n按名称分类A阿里云\nAGE动漫\nBBiliBili\n博客园\nC拷貝漫畫\nCodeforces\nD戴森球计划蓝图预览\n戴森球计划量产量化计算器工具\nEEasyGPT\nFflorr.io\nFlorr.io Wiki\nGGoogle开源项目风格指南\nGraph Editor\nHHexo\nHexo Aurora Docs\nHTML5 Speedtest\nIJKL蓝奏云\nLaTeX-symbols.pdf\n莉莉云\n洛谷\n洛谷帖子保存站\n洛谷题目测试点配置文件\nLuoguLite开发文档\nMMinecraft Wiki\nMinecraft1.20及以上版本FabricMod开发可能遇到的问题\nMini Billar\nMySQL教程\nNOOeis\nOfficial Honkai Impact 3 Wiki\nOIso++\nOI Wiki\nPPixiv\nPython3文档\nQQBXTOJ\n雀魂\nRRoad 2 coding\nS傻狗本狗の小破站\n圣芙蕾雅档案馆\nSM.MS\nTTestlib使用指南\nTETR.IO\nUUOJ部署指北\nUSTC开源软件镜像站\nVWWGSZ Online Judge\nX下载\nY樱花Frp\n元气Shop\nZ#126邮箱\n","slug":"实用网站索引","date":"2023-09-21T22:55:42.000Z","categories_index":"","tags_index":"工具","author_index":"Badnuker"},{"id":"c3c6ea79e312bab1580426de428b17c5","title":"初赛中的排序算法","content":"（注：如未标注，表中信息均来源于 OI Wiki）\n\n\n\n算法\n时间复杂度（平均）\n时间复杂度（最优）\n时间复杂度（最差）\n稳定性\n\n\n\n选择排序\n\n\n\n不稳定\n\n\n冒泡排序\n\n\n\n稳定\n\n\n插入排序\n\n\n\n稳定\n\n\n计数排序\n\n\n\n稳定\n\n\n基数排序\n\n\n\n稳定\n\n\n快速排序\n\n\n\n不稳定\n\n\n归并排序\n\n\n\n稳定\n\n\n堆排序\n\n\n\n不稳定\n\n\n桶排序\n\n\n\n稳定\n\n\n希尔排序\n根据步长序列的不同而不同 \n\n\n不稳定\n\n\n参考资料\n希尔排序 - 维基百科，自由的百科全书\n\n","slug":"初赛中的排序算法","date":"2023-09-21T22:53:38.000Z","categories_index":"","tags_index":"算法基础","author_index":"Badnuker"},{"id":"408d284ba38138d0b621ff151bb14130","title":"Markdown&Latex测试","content":"\n\ncpp#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn = 5e5 + 5;\n\nint tot, ccnt;\nint deg[maxn];\nunordered_map&lt;string, int&gt; col;\nvector&lt;int&gt; p[maxn];\n\nstruct DSU {\n    int fa[maxn];\n    DSU() {\n        for (int i = 1; i &lt; maxn; i++) {\n            fa[i] = i;\n        }\n    }\n    int getfa(int x) {\n        if (fa[x] == x) {\n            return x;\n        } else {\n            return fa[x] = getfa(fa[x]);\n        }\n    }\n\n    bool merge(int x, int y) {\n        int fx = getfa(x), fy = getfa(y);\n        if (fx == fy) {\n            return 0;\n        }\n        fa[fx] = fy;\n        return 1;\n    }\n} dsu;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    string s, t;\n    while (cin &gt;&gt; s &gt;&gt; t) {\n        if (!col[s]) {\n            col[s] = ++tot;\n        }\n        if (!col[t]) {\n            col[t] = ++tot;\n        }\n        if (dsu.merge(col[s], col[t])) {\n            ccnt++;\n        }\n        p[col[s]].push_back(col[t]);\n        p[col[t]].push_back(col[s]);\n        deg[col[s]]++, deg[col[t]]++;\n    }\n    if (ccnt &lt; tot - 1) {\n        cout &lt;&lt; \"Impossible\\n\";\n        return 0;\n    }\n    int cnt = 0;\n    for (int i = 1; i &lt;= tot; i++) {\n        if ((deg[i] &amp; 1) &amp;&amp; ++cnt &gt; 2) {\n            cout &lt;&lt; \"Impossible\\n\";\n            return 0;\n        }\n    }\n    cout &lt;&lt; \"Possible\\n\";\n    return 0;\n}","slug":"Markdown-Latex测试","date":"2023-09-20T23:40:20.000Z","categories_index":"","tags_index":"测试","author_index":"Badnuker"}]