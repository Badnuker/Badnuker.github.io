[{"id":"388a2cc7ccd390e63439623ba88b8119","title":"实用网站索引","content":"（实时更新中）\n未分类BiliBili\n洛谷\n雀魂\n樱花Frp\nRoad 2 coding\n戴森球计划量产量化计算器工具\n戴森球计划蓝图预览\n莉莉云\nMinecraft Wiki\nGraph Editor\nPython3文档\n傻狗本狗の小破站\nUOJ部署指北\nMySQL教程\n蓝奏云\nWGSZ Online Judge\nAGE动漫\n拷貝漫畫\nMinecraft1.20及以上版本FabricMod开发可能遇到的问题\n圣芙蕾雅档案馆\nOfficial Honkai Impact 3 Wiki\nflorr.io\n下载\nCodeforces\nQBXTOJ\nOI Wiki\n数论杀手（oeis）\nEasyGPT\nGoogle开源项目风格指南\n洛谷题目测试点配置文件\nOIso++\nTestlib使用指南\n洛谷帖子保存站\nLuoguLite开发文档\nFlorr.io Wiki\nTETR.IO\nMini Billar\n博客园\nLaTeX-symbols.pdf\nUSTC开源软件镜像站\nSM.MS\n阿里云\nHTML5 Speedtest\n126邮箱\n","slug":"实用网站索引","date":"2023-09-21T22:55:42.000Z","categories_index":"","tags_index":"工具","author_index":"Badnuker"},{"id":"c3c6ea79e312bab1580426de428b17c5","title":"初赛中的排序算法","content":"（注：如未标注，表中信息均来源于 OI Wiki）\n\n\n\n算法\n时间复杂度（平均）\n时间复杂度（最优）\n时间复杂度（最差）\n稳定性\n\n\n\n选择排序\n\n\n\n不稳定\n\n\n冒泡排序\n\n\n\n稳定\n\n\n插入排序\n\n\n\n稳定\n\n\n计数排序\n\n\n\n稳定\n\n\n基数排序\n\n\n\n稳定\n\n\n快速排序\n\n\n\n不稳定\n\n\n归并排序\n\n\n\n稳定\n\n\n堆排序\n\n\n\n不稳定\n\n\n桶排序\n\n\n\n稳定\n\n\n希尔排序\n根据步长序列的不同而不同 \n\n\n不稳定\n\n\n参考资料\n希尔排序 - 维基百科，自由的百科全书\n\n","slug":"初赛中的排序算法","date":"2023-09-21T22:53:38.000Z","categories_index":"","tags_index":"算法基础","author_index":"Badnuker"},{"id":"408d284ba38138d0b621ff151bb14130","title":"Markdown&Latex测试","content":"\n\ncpp#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn = 5e5 + 5;\n\nint tot, ccnt;\nint deg[maxn];\nunordered_map&lt;string, int&gt; col;\nvector&lt;int&gt; p[maxn];\n\nstruct DSU {\n    int fa[maxn];\n    DSU() {\n        for (int i = 1; i &lt; maxn; i++) {\n            fa[i] = i;\n        }\n    }\n    int getfa(int x) {\n        if (fa[x] == x) {\n            return x;\n        } else {\n            return fa[x] = getfa(fa[x]);\n        }\n    }\n\n    bool merge(int x, int y) {\n        int fx = getfa(x), fy = getfa(y);\n        if (fx == fy) {\n            return 0;\n        }\n        fa[fx] = fy;\n        return 1;\n    }\n} dsu;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    string s, t;\n    while (cin &gt;&gt; s &gt;&gt; t) {\n        if (!col[s]) {\n            col[s] = ++tot;\n        }\n        if (!col[t]) {\n            col[t] = ++tot;\n        }\n        if (dsu.merge(col[s], col[t])) {\n            ccnt++;\n        }\n        p[col[s]].push_back(col[t]);\n        p[col[t]].push_back(col[s]);\n        deg[col[s]]++, deg[col[t]]++;\n    }\n    if (ccnt &lt; tot - 1) {\n        cout &lt;&lt; \"Impossible\\n\";\n        return 0;\n    }\n    int cnt = 0;\n    for (int i = 1; i &lt;= tot; i++) {\n        if ((deg[i] &amp; 1) &amp;&amp; ++cnt &gt; 2) {\n            cout &lt;&lt; \"Impossible\\n\";\n            return 0;\n        }\n    }\n    cout &lt;&lt; \"Possible\\n\";\n    return 0;\n}","slug":"Markdown-Latex测试","date":"2023-09-20T23:40:20.000Z","categories_index":"","tags_index":"测试","author_index":"Badnuker"}]