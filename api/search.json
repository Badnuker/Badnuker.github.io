[{"id":"a24e47ab9cd1113e77c93f617c7465c0","title":"NOIP2023游记","content":"（省流 ：寄了）\nT1 很好想，发现复杂度不对，开始想 trie 树。\n发现空间爆了，于是想到  做法，写完后测大样例发现比  慢（雾），于是把两种做法拼了起来。\n回到家才发现两个做法复杂度都是错的…\n只能指望 O2 和ccf的少爷机了。\nT2一眼建图。\n然后连了一个小时的边，还是不会，开始拼暴力。\n输入数据给了测试点编号，算是做了点人事/kel/kel/kel\nT3啊？\nDPing…\n想特殊性质ing…\n想暴力ing…\n啊？只会  pt。\nT4一眼 DP。\n流畅的写出  的代码，一看时间，寄。\n总结写了的分： pt。\n实际得分：（待更新）。\nAFO 了，Byebye World。\n","slug":"NOIP2023游记","date":"2023-11-19T18:47:27.000Z","categories_index":"","tags_index":"游记","author_index":"Badnuker"},{"id":"3ff1fccb551d916fe3dfc94fb9c855a9","title":"C++ pb_ds库学习笔记","content":"前言pb_ds 库是 gnu 内置的一个功能强大的库，封装了许多常用但代码量大的数据结构，例如 红黑树、Splay、可并堆…\n需要新引入的头文件和命名空间：\ncpp#include&lt;bits/extc++.h&gt;\nusing namespace __gnu_cxx;\nusing namespace __gnu_pbds;（注意：Clang++ 中没有此扩展库，需要使用 g++ 编译器）\n堆声明cpptemplate&lt;class _Tv, class Cmp_Fn = std::less&lt;__gnu_pbds::priority_queue&lt;_Tv, Cmp_Fn, Tag, _Alloc&gt;::value_type&gt;, class Tag = __gnu_pbds::pairing_heap_tag, class _Alloc = std::allocator&lt;char&gt;&gt; class __gnu_pbds::priority_queue&lt;_Tv, Cmp_Fn, Tag, _Alloc&gt;解析：\n\n_Tv：堆中元素的类型\nCmp_Fn：比较函数，默认为 less，与 std::priority_queue 相同，为大根堆\nTag：默认即可\n_Alloc：别管\n\n定义定义一个存整数的小根堆：\ncpp__gnu_pbds::priority_queue&lt;int,greater&lt;int&gt;&gt; q;（为与 STL 区分开，此处应指定命名空间 __gnu_pbds::）\n用法区别于 STL 的实用用法：\npush：pb_ds 中的 push 函数具有返回值，返回被 push 元素的迭代器\nmodify：传入 (迭代器，新值)，将迭代器所指向的元素变成新的值\njoin：用法形如 a.join(b) ，将 b 堆合并到 a 堆（需要两个堆定义相同），并清空 b 堆\n例题洛谷P3377 【模板】左偏树&#x2F;可并堆\n通过代码（O2：212ms）：\ncpp#include&lt;bits/stdc++.h&gt;\n#include&lt;bits/extc++.h&gt;\nusing namespace std;\nusing namespace __gnu_cxx;\nusing namespace __gnu_pbds;\nconst int maxn = 1e5 + 5;\n\nint n, m;\nint d[maxn];\nint fa[maxn];\n__gnu_pbds::priority_queue&lt;pair&lt;int, int&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q[maxn];\n\nint getfa(int x) &#123;\n    if (fa[x] == x) &#123;\n        return x;\n    &#125; else &#123;\n        return fa[x] = getfa(fa[x]);\n    &#125;\n&#125;\n\nint main() &#123;\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1, x; i &lt;= n; i++) &#123;\n        cin &gt;&gt; x;\n        q[i].push(&#123;x, i&#125;);\n        fa[i] = i;\n    &#125;\n    for (int i = 1, opt, x, y; i &lt;= m; i++) &#123;\n        cin &gt;&gt; opt;\n        if (opt == 1) &#123;\n            cin &gt;&gt; x &gt;&gt; y;\n            if (d[x] || d[y]) &#123;\n                continue;\n            &#125;\n            int fx = getfa(x), fy = getfa(y);\n            if (fx == fy) &#123;\n                continue;\n            &#125;\n            fa[fx] = fy;\n            q[fy].join(q[fx]);\n        &#125; else &#123;\n            cin &gt;&gt; x;\n            if (d[x]) &#123;\n                cout &lt;&lt; -1 &lt;&lt; &#39;\\n&#39;;\n                continue;\n            &#125;\n            int ff = getfa(x);\n            cout &lt;&lt; q[ff].top().first &lt;&lt; &#39;\\n&#39;;\n            d[q[ff].top().second] = 1;\n            q[ff].pop();\n        &#125;\n    &#125;\n    return 0;\n&#125;未完待续…","slug":"Cpp-pbds库学习笔记","date":"2023-11-15T22:36:45.000Z","categories_index":"","tags_index":"杂项","author_index":"Badnuker"},{"id":"9e6265357233104fab609d4c9c78c596","title":"CSP-S 2023游记","content":"T1密码就  位，一眼丁真鉴定为暴力。\n枚举正确密码，判断能否变出所给的  种状态。\n只转一个拨圈的简单，只有一个数不就行。\n对于需要转两个拨圈的，打个表，暴力记两个拨圈同时旋转能变成啥。\nT2最大惨案，做了  个小时才发现是子串不是子序列（寄）。\n考场上联想到括号序列，但我用的是链表维护，枚举子串，拿了  的部分分。\n出来听同机房大佬们交流才发现可以用栈，多  pt。\nT3煞笔大模拟，初升出题人。\nT4不会。\n总结写了的分： pt。\n实际得分： pt。\n一等到手。\n","slug":"CSP-S-2023游记","date":"2023-10-22T19:15:02.000Z","categories_index":"","tags_index":"游记","author_index":"Badnuker"},{"id":"9c99dc11ee58b9118dc125cce366c4cd","title":"非常好矩阵封装","content":"Tips\n支持直接 cin, cout\n\nCodecppnamespace Badnuker &#123;\n    const int mod = 1e9 + 7;\n\n    class Matrix &#123;\n        public:\n            int row, col;\n            int a[105][105];\n\n            Matrix() &#123;\n                memset(a, 0, sizeof(a));\n            &#125;\n\n            Matrix(int x, int y) &#123;\n                row = x;\n                col = y;\n                memset(a, 0, sizeof(a));\n            &#125;\n\n            friend istream &amp; operator&gt;&gt;(istream &amp;is, Matrix &amp;x) &#123;\n                for (int i = 1; i &lt;= x.row; i++) &#123;\n                    for (int j = 1; j &lt;= x.col; j++) &#123;\n                        is &gt;&gt; x.a[i][j];\n                    &#125;\n                &#125;\n                return is;\n            &#125;\n\n            friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Matrix &amp;x) &#123;\n                for (int i = 1; i &lt;= x.row; i++) &#123;\n                    for (int j = 1; j &lt;= x.col; j++) &#123;\n                        os &lt;&lt; x.a[i][j] &lt;&lt; &#39; &#39;;\n                    &#125;\n                    if (i != x.row) &#123;\n                        os &lt;&lt; &#39;\\n&#39;;\n                    &#125;\n                &#125;\n                return os;\n            &#125;\n\n            Matrix operator*(const Matrix &amp; x) &#123;\n                Matrix res(row, x.col);\n                for (int i = 1; i &lt;= row; i++) &#123;\n                    for (int k = 1; k &lt;= col; k++) &#123;\n                        int tmp = a[i][k];\n                        for (int j = 1; j &lt;= x.col; j++) &#123;\n                            (res.a[i][j] += tmp * x.a[k][j]) %= mod;\n                        &#125;\n                    &#125;\n                &#125;\n                return res;\n            &#125;\n\n            void operator*=(const Matrix &amp; x) &#123;\n                (*this) = (*this) * x;\n            &#125;\n\n            void operator%=(const int &amp;x __attribute__((unused))) &#123;&#125;\n    &#125;;\n\n    template&lt;typename T&gt;\n    T ksm(T x, int y) &#123;\n        T res = x;\n        y--;\n        while (y) &#123;\n            if (y &amp; 1) &#123;\n                res *= x;\n            &#125;\n            x *= x;\n            y &gt;&gt;= 1;\n        &#125;\n        return res;\n    &#125;\n&#125;","slug":"非常好矩阵封装","date":"2023-09-29T20:13:34.000Z","categories_index":"","tags_index":"模板","author_index":"Badnuker"},{"id":"388a2cc7ccd390e63439623ba88b8119","title":"实用网站索引","content":"（实时更新中）\n按名称分类A阿里云\nAGE动漫\nBBiliBili\n博客园\nC拷貝漫畫\nCodeforces\nD戴森球计划蓝图预览\n戴森球计划量产量化计算器工具\nEEasyGPT\nFflorr.io\nFlorr.io Wiki\nGGoogle开源项目风格指南\nGraph Editor\nHHexo\nHexo Aurora Docs\nHTML5 Speedtest\nIJKL蓝奏云\nLaTeX-symbols.pdf\n莉莉云\n洛谷\n洛谷帖子保存站\n洛谷题目测试点配置文件\nLuoguLite开发文档\nMMinecraft Wiki\nMinecraft1.20及以上版本FabricMod开发可能遇到的问题\nMini Billar\nMySQL教程\nNOOeis\nOfficial Honkai Impact 3 Wiki\nOIso++\nOI Wiki\nPPixiv\nPython3文档\nQQBXTOJ\n雀魂\nRRoad 2 coding\nS傻狗本狗の小破站\n圣芙蕾雅档案馆\nSM.MS\nTTestlib使用指南\nTETR.IO\nUUOJ部署指北\nUSTC开源软件镜像站\nVWWGSZ Online Judge\nX下载\nY樱花Frp\n元气Shop\nZ#126邮箱\n","slug":"实用网站索引","date":"2023-09-21T22:55:42.000Z","categories_index":"","tags_index":"工具","author_index":"Badnuker"},{"id":"c3c6ea79e312bab1580426de428b17c5","title":"初赛中的排序算法","content":"（注：如未标注，表中信息均来源于 OI Wiki）\n\n\n\n算法\n时间复杂度（平均）\n时间复杂度（最优）\n时间复杂度（最差）\n稳定性\n\n\n\n选择排序\n\n\n\n不稳定\n\n\n冒泡排序\n\n\n\n稳定\n\n\n插入排序\n\n\n\n稳定\n\n\n计数排序\n\n\n\n稳定\n\n\n基数排序\n\n\n\n稳定\n\n\n快速排序\n\n\n\n不稳定\n\n\n归并排序\n\n\n\n稳定\n\n\n堆排序\n\n\n\n不稳定\n\n\n桶排序\n\n\n\n稳定\n\n\n希尔排序\n根据步长序列的不同而不同 \n\n\n不稳定\n\n\n参考资料\n希尔排序 - 维基百科，自由的百科全书\n\n","slug":"初赛中的排序算法","date":"2023-09-21T22:53:38.000Z","categories_index":"","tags_index":"算法基础","author_index":"Badnuker"},{"id":"408d284ba38138d0b621ff151bb14130","title":"Markdown&Latex测试","content":"\n\ncpp#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn = 5e5 + 5;\n\nint tot, ccnt;\nint deg[maxn];\nunordered_map&lt;string, int&gt; col;\nvector&lt;int&gt; p[maxn];\n\nstruct DSU {\n    int fa[maxn];\n    DSU() {\n        for (int i = 1; i &lt; maxn; i++) {\n            fa[i] = i;\n        }\n    }\n    int getfa(int x) {\n        if (fa[x] == x) {\n            return x;\n        } else {\n            return fa[x] = getfa(fa[x]);\n        }\n    }\n\n    bool merge(int x, int y) {\n        int fx = getfa(x), fy = getfa(y);\n        if (fx == fy) {\n            return 0;\n        }\n        fa[fx] = fy;\n        return 1;\n    }\n} dsu;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    string s, t;\n    while (cin &gt;&gt; s &gt;&gt; t) {\n        if (!col[s]) {\n            col[s] = ++tot;\n        }\n        if (!col[t]) {\n            col[t] = ++tot;\n        }\n        if (dsu.merge(col[s], col[t])) {\n            ccnt++;\n        }\n        p[col[s]].push_back(col[t]);\n        p[col[t]].push_back(col[s]);\n        deg[col[s]]++, deg[col[t]]++;\n    }\n    if (ccnt &lt; tot - 1) {\n        cout &lt;&lt; \"Impossible\\n\";\n        return 0;\n    }\n    int cnt = 0;\n    for (int i = 1; i &lt;= tot; i++) {\n        if ((deg[i] &amp; 1) &amp;&amp; ++cnt &gt; 2) {\n            cout &lt;&lt; \"Impossible\\n\";\n            return 0;\n        }\n    }\n    cout &lt;&lt; \"Possible\\n\";\n    return 0;\n}","slug":"Markdown-Latex测试","date":"2023-09-20T23:40:20.000Z","categories_index":"","tags_index":"测试","author_index":"Badnuker"}]